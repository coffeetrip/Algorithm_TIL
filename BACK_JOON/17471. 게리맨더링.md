### 17471. 게리맨더링

```python
def bfs(k, N):
    global people
    queue = [k[0]]
    visited = [0]*(N+1)
    visited[k[0]] = 1

    total = 0
    while len(queue):
        i = queue.pop(0)
        total += people[i]
        for j in k:
            if adj[i][j] == 1 and visited[j] == 0:
                queue.append(j)
                visited[j] = visited[i] + 1
    for i in k:
        if visited[i] == 0:
            return 0
    return total

N = int(input())
people = [0] + list(map(int, input().split()))
adj = [[0]*(N+1) for _ in range(N+1)]  # 인접행렬
for i in range(1, N+1):
    node = list(map(int, input().split()))
    for j in node[1:]:
        adj[i][j] = 1
        adj[j][i] = 1

minV = 10000000000000000
for i in range(1, (1<<N)//2):
    A, B = [], []
    for j in range(N):
        if i & (1<<j) != 0:
            A.append(j+1)   # j+1을 선거구 번호로 활용
        else:
            B.append(j+1)

    # 각 그룹을 탐색하고 인구 차이를 구함
    rA = bfs(A, N)   # 선거구가 끊어져 있는 경우 0 리턴
    rB = bfs(B, N)   # 선거구가 이어진 경우 선거구 인구의 합 리턴

    if rA * rB != 0:  # 양쪽 선거구가 정상적으로 연결되어 있으면
        if minV > abs(rA-rB):
            minV = abs(rA-rB)


# 모든 구역 분할에 대한 검투가 끝나면
if minV == 10000000000000000:  # 모든 선거구가 구성 불가능하면
    minV = -1

print(minV)
```

