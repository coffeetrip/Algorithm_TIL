### 14502. 연구소

```python
def bfs():
    global queue, visited, tt
    while queue:
        i, j = queue.pop(0)
        di = [0, 1, 0, -1]
        dj = [1, 0, -1, 0]
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < N and 0 <= nj < M and visited[ni][nj] == 0 and zido[ni][nj] == 0:
                visited[ni][nj] = 1
                tt += 1
                queue.append([ni, nj])

    result = N*M - tt
    return result


N, M = map(int, input().split())  # 세로, 가로
zido = [list(map(int, input().split())) for _ in range(N)]  # 0 빈칸, 1 벽, 2 바이러스


temp = []
for i in range(N):
    for j in range(M):
        if zido[i][j] == 0:
            temp.append([i, j])


temp_N = len(temp)
security = 0
for i in range(temp_N-2):
    for j in range(i+1, temp_N-1):
        for k in range(j+1, temp_N):
            zido[temp[i][0]][temp[i][1]] = 1
            zido[temp[j][0]][temp[j][1]] = 1
            zido[temp[k][0]][temp[k][1]] = 1
            queue = []
            visited = [[0] * M for _ in range(N)]
            tt = 0
            for m in range(N):
                for n in range(M):
                    if zido[m][n] == 2:
                        queue.append([m, n])
                        visited[m][n] = 1
                        tt += 1
                    elif zido[m][n] == 1:
                        tt += 1
            tt = bfs()
            if security < tt:
                security = tt
            zido[temp[i][0]][temp[i][1]] = 0
            zido[temp[j][0]][temp[j][1]] = 0
            zido[temp[k][0]][temp[k][1]] = 0

print(security)
```

```PYTHON
di = [0, 1, 0, -1]
dj = [1, 0, -1, 0]
def bfs(lab, N, M):
    global maxV
    f = -1
    r = -1
    q = [0]*N*M*2  # 큐 생성
    visited = [[0]*M for _ in range(N)]  # visited 생성
    for i in range(N):  # 시작점 인큐 및 visited 방문 표시
        for j in range(M):  
            if lab[i][j] == 2:
                r += 1
                q[r] = i
                r += 1
                q[r] = j
                visited[i][j] = 1
    while f != r:   # 큐가 비어있지 않으면 반복
        f += 1  # 디큐
        i = q[f]
        f += 1
        j = q[f]
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < N and 0 <= nj < M: 
                if lab[ni][nj] == 0 and visited[ni][nj] == 0:   # 인접이면(빈공간이고 바이러스가 퍼지지 않았으면)
                    r += 1
                    q[r] = ni
                    r += 1
                    q[r] = nj
                    visited[ni][nj] = visited[i][j] + 1
    # 모든 칸에 대해 lab[i][j]와 visited[i][j]가 0인 칸 수를 maxV와 비교
    cnt = 0
    for i in range(N):
        for j in range(M):
            if lab[i][j] == 0 and visited[i][j] == 0:
                cnt += 1
    if maxV < cnt:
        maxV = cnt

N, M = map(int, input().split())
lab = [list(map(int, input().split())) for _ in range(N)]
maxV = 0

# 3개의 기둥을 세울 칸의 번호를 정한다.
for i in range(N*M-2):  # 첫번째 기둥
    if lab[i//M][i%M] == 0:  # 기둥을 세울 수 있으면
        for j in range(i+1, N*M-1):  # 두 번째 기둥
            if lab[j//M][j%M] == 0:
                for k in range(j+1, N*M):  # 세 번째 개둥
                    if lab[k//M][k%M] == 0:
                        lab[i // M][i % M] = 1  # 해당 위치에 기둥을 세우고
                        lab[j // M][j % M] = 1
                        lab[k // M][k % M] = 1
                        bfs(lab, N, M)
                        lab[i // M][i % M] = 0  # 다른 위치에 기둥을 세우려면
                        lab[j // M][j % M] = 0
                        lab[k // M][k % M] = 0

print(maxV)
```

