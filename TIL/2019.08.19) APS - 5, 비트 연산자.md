# 2019.08.19) APS - 5. 비트 연산자

### 비트 연산자

 `&`  : 비트단위로 AND 연산(논리연산 AND와 다름)(특정비트를 검사)

 `|`  : 비트단위로 OR 연산

 `<<`  : 피연산자의 비트 열을 왼쪽으로 이동

 `>>` : 피연산자의 비트 열을 오른쪽으로 이동

#### &

```
  00001111
& 00001011
------------
  00001011
```

정의 : 하나만 0이면 0(둘 다 1일 때 1)

기능 : 특정 비트를 0으로 만들 때 사용, 특정비트를 검사

#### |

```
  00001111
| 01000001
-----------
  01001111
```

정의 : 하나라도 1이면 1(둘 다 0이면 0)

기능 : 특정 비트를 1로 만들 때 사용

#### << , >>

```
3번 비트를 1로 만들기
00001000  == <<3 == 2^3
```

```
n번 비트가 1인 값
1<<n
```

```
a의 3번 비트를 1로 만들기
a = a | (a<<3)  
```

```
3번 비트만 0인 값
11110111  == ~(1<<3)   3번비트를 1로 만들어서 뒤집어			
```

#### & 연산자

i & (1<<j) : i의 j번째 비트가 1인자리

```
j번 비트 검사
1<<j  j번 비트가 1인값
j==3 : 0000 1000
i & (1<<3)

i   00001111
&   00001000
--------------
    00001000   !=0  (3번비트가 1이면 결과는 0이 아님)
    
i   10110111
&   00001000
--------------
    00000000  ==0   (3번비트가 0이면 결과는 0)
```





```python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr)  # n : 원소의 개수

for i in range(1<<n):  # 1<<n : 부분집합의 개수(2^n)
    for j in range(n):  # 원소의 수만큼 비트를 비교함
        if i & (1<<j):   # i의 j번째 비트가 1이면 j번째 원소 출력
            print(arr[j], end=", ")
        print()
    print()
```
