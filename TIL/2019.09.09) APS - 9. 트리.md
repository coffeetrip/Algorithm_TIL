# 2019.09.09) APS - 9. 트리

## 용어

노드(node) : 트리의 원소

간선(edge): 노드를 연결하는 선, 부모 노드와 자식 노드를 연결

루트 노드(root node) : 트리의 시작 노드

형제 노드(sibling node) : 같은 부모 노드의 자식 노드들

조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들

서브 트리(subtree) : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리

자손 노드 : 서브 트리에 있는 하위 레벨의 노드들







## 이진트리 

: 모든 노드들이 2개 이하의 서브트리를 갖는 형태의 트리

레벨i에서 노드의 최대 개수 : 2^i

높이가 h인 이진 트리의 노드의 최소 개수는(h+1)개, 최대 개수는(2^(h+1)-1)개

```python
# 이진트리 정보
5 4   # 노드의 개수 V, 간선의 개수 E
2 1 2 4 4 3 4 5  # 부모, 자식
```

저장 방법

```python
# 부모를 인덱스로 자식번호를 저장
for i in range(1, N):
    read p, c
    if ch[p] == 0:
        ch1[p] = c
    else:
        ch2[p] = c
```

```python
# 자식 번호를 인덱스로 부모 번호를 저장
for i in range(1, N):
    read p, c
    pa[c] = p
```

루트 찾기

```python
1. 루트 찾기(부모가 없는 노드 찾기)

2. 조상 노드 찾기
c = 5
while a[c] != 0:  # 루트인지 확인
    c = a[c]
    print(c)
```



순회 : 트리의 노드를 중복없이 방문

```
13
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
```

```python
def preorder(n):
    if n>0:
        print(n, end=" ")
        preorder(ch1[n])
        preorder(ch2[n])

def inorder(n):
    if n>0:
        inorder(ch1[n])
        print(n, end=" ")
        inorder(ch2[n])

def postorder(n):
    if n>0:
        postorder(ch1[n])
        postorder(ch2[n])
        print(n, end=" ")

def f(n):   # n의 조상 출력하기
    while par[n] != 0:     # n의 부모가 있으면
        print(par[n], end=" ")
        n = par[n]        # 부모를 새로운 자식으로 해서 부모의 부모를 찾으러 감


V = int(input())   # 간선 수 = V - 1
E = V - 1   # 간선 수
t = list(map(int, input().split()))

ch1 = [0] * (V+1)   # 부모를 인덱스로 자식 저장
ch2 = [0] * (V+1)
par = [0] * (V+1)   # 자식을 인덱스로 부모 저장

for i in range(E):  # 간선의 개수만큼
    p = t[2*i]
    c = t[2*i + 1]
    if  ch1[p] == 0:  # 아직 ch1 자식이 없으면
        ch1[p] = c
    else:
        ch2[p] = c
    par[c] = p


preorder(1)
print()
inorder(1)
print()
postorder(1)
print()
f(13)
```

```
[0, 2, 4, 5, 7, 8, 10, 12, 0, 0, 0, 13, 0, 0]
[0, 3, 0, 6, 0, 9, 11, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 11]
1 2 4 7 12 3 5 8 9 6 10 11 13 
12 7 4 2 1 8 5 9 3 10 6 13 11 
12 7 4 2 8 9 5 10 13 11 6 3 1 
11 6 3 1
```





이진 트리 순회

```python
# 재귀 : 존재한지 검사한 후 들어감
DLR(1):
    Visite()
    if Left:
        DLR()
    if Right:
        DLR()
```

```PYTHON
# 들어간뒤 검사
F(1)
	if():
        V(1)
        f()
        f()
```





 ex

```python
# 1번 노드부터 이진트리를 순회하고 방문한 노드의 개수를 출력
f(1)
	if(1)
    	cnt += 1
        f(2)
        f(3)
```





## 이진트리 - 종류

### 포화이진트리

모든 노드가 다 차있는 상태

노드 번호에 규칙성이 있다.



### 완전이진트리

마지막레벨의 오른쪽 끝에서 순서대로 빠져있다.



### 편향 이진 트리 

트리가 한쪽으로 치우쳐지는 현상으로 효율성이 떨어진다.(레드? : 차수를 낮춰준다.)



### 이진트리의 표현 

이 그림은 완전이진트리의 그림이다.

정수형나누기 2를 하면 부모 노드 번호가 된다.

부모 노드 번호[i/2], 왼쪽 자식 노드 번호[2*i], 오른쪽 자식 노드 번호[2*i+1]

레벨 n의 노드 번호 시작 번호[2^n]











트리의 표현 - 연결리스트

이진 트리의 표현의 단점을 보완하기 위해 연결 리스트를 이용하여 트리를 표현

왼쪽 자식 노드, 데이터, 오른쪽 자식 노드

메모리를 효율적으로 사용할 수 있지만, 속도가 오래걸린다.



정점의 개수 = 엣지?의 개수 + 1







수식트리







이진 탐색 트리











인접행렬(간선의 방향x)

그래프 저장

```python
read V,E
for i in range(1, E):
    read n1, n2
    M[n1][n2] = 1
    M[n2][n1] = 1
```

