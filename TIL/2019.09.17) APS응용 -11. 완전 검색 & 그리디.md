# 2019.09.17) APS응용 -11. 완전 검색 & 그리디

### 순열

```python
# {1,2,3}을 포함하는 모든 순열을 생성하는 함수
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i1 != i2:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```



```python
# 재귀 호출을 통한 순열 생성 - 주어진 3개의 숫자로 만드는 순열

def perm(n, k):   # n: 교환된 원소의 개수  , k: 원소의 개수
    if n == k:
        print(p)
    else:
        for i in range(n, k):
            p[n], p[i] = p[i], p[n]
            perm(n+1, k)   # 다음 자리를 결정
            p[n], p[i] = p[i], p[n]  # 원래 자리로 복귀


p = [1, 2, 3]
perm(0, 3)
```

```
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 2, 1]
[3, 1, 2]
```



```python
# 재귀 호출을 통한 순열 생성 - 주어진 5개의 숫자중 3개를 숫자로 만드는 순열

def perm(n, k, m):   # n: 교환된 원소의 개수  , k: 원소의 개수
    if n == k:
        print(p[:3])
    else:
        for i in range(n, m):
            p[n], p[i] = p[i], p[n]
            perm(n+1, k, m)   # 다음 자리를 결정
            p[n], p[i] = p[i], p[n]


p = [1, 2, 3, 4, 5]
perm(0, 3, 5)
```

```
[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 3, 2]
[1, 3, 4]
[1, 3, 5]
[1, 4, 3]
[1, 4, 2]
[1, 4, 5]
[1, 5, 3]
[1, 5, 4]
[1, 5, 2]
[2, 1, 3]
[2, 1, 4]
[2, 1, 5]
[2, 3, 1]
[2, 3, 4]
[2, 3, 5]
[2, 4, 3]
[2, 4, 1]
[2, 4, 5]
[2, 5, 3]
[2, 5, 4]
[2, 5, 1]
[3, 2, 1]
[3, 2, 4]
[3, 2, 5]
[3, 1, 2]
[3, 1, 4]
[3, 1, 5]
[3, 4, 1]
[3, 4, 2]
[3, 4, 5]
[3, 5, 1]
[3, 5, 4]
[3, 5, 2]
[4, 2, 3]
[4, 2, 1]
[4, 2, 5]
[4, 3, 2]
[4, 3, 1]
[4, 3, 5]
[4, 1, 3]
[4, 1, 2]
[4, 1, 5]
[4, 5, 3]
[4, 5, 1]
[4, 5, 2]
[5, 2, 3]
[5, 2, 4]
[5, 2, 1]
[5, 3, 2]
[5, 3, 4]
[5, 3, 1]
[5, 4, 3]
[5, 4, 2]
[5, 4, 1]
[5, 1, 3]
[5, 1, 4]
[5, 1, 2]
```





```python
def f(n, k):
    if n==k:
        print(p)
    else:  
        for i in range(k):
            if used[i] == 0:
                used[i] = 1
                p[n] = a[i]
                f(n+1, k)
                used[i] = 0
                

p = list(input())
N = 길이
used = [0]*(N-1)
f(0, N-1)
```









### baby_gin - 완전탐색

```python
def perm(n, k):
    if n == k:
        #print(p)
        run = 0
        tri = 0

        if p[0] == p[1] == p[2]:
            tri += 1
        if p[3] == p[4] == p[5]:
            tri += 1
        if p[2] == p[1]+1 == p[0]+2:
            run += 1
        if p[5] == p[4]+1 == p[3]+2:
            run += 1

        if run + tri == 2:
            print('baby-gin')

    else:
        for i in range(n, k):
            p[n], p[i] = p[i], p[n]
            perm(n + 1, k)  # 다음 자리를 결정
            p[n], p[i] = p[i], p[n]


p = list(map(int, input()))
perm(0, 6)
```





### 부분집합 생성

```python
# 바이러니 카운팅
arr = list(input())
N = len(arr)

for i in range(1<<N):    # 공집합제거 : range(1, 1<<N)
    for j in range(N):
        if i & (1<<j):
            print(arr[j], end="")
        print()
```

```python
N, S = map(int, input().split())
num = list(map(int, input().split()))
bit = [0] * N
cnt = 0

f(0, N, S)
f2(0, N, S, 0, 0)
print(cnt)
```

```python
# 재귀
def f(n, k, S):
    global cnt
    if n == k:   # 부분 집합이 완성되면
        if sum(bit) != 0:  # 공집합이 아닌 경우
            t = 0
            for i in range(k):  
                if bit[i] == 1:
                    t += num[i]
            if t == S:  
                cnt += 1
    else:
        bit[n] = 0   
        f(n + 1, k, S)
        bit[n] = 1       # 부분집합에 num[n]을 포함
        f(n + 1, k, S)
```

```python
# 재귀(빠름)
def f2(n, k, S, ts, m):   # ts현재까지 포함한 원소의 합, 원소의 개수
    global cnt
    if n == k:
        if m > 0 and ts == S:
            cnt += 1
    else:
        f2(n+1, k, S, ts, m)
        f2(n+1, k, S, ts+num[n], m+1)
```

백준 구슬탈출 문제 풀어보기

```python
a = [3, 6]

[] -> bit = [0, 0]		00
[6] -> bit = [0, 1]		01
[3] -> bit = [1, 0]		10
[3, 6] -> bit = [1, 1]	11

for j in range(2):
    if bit[j] == 1:
        print(a[j], end="")
```







### 조합

n개에서 r개를 고를 때, 어떤 1개를 포함하는 경우와 포함하지 않는 경우로 나눈다.

```python
an[] : n개의 원소를 가지고 있는 배열
tr[] : r개의 크기를 배열, 조합이 임시 저장될 배열

def comb(n, r):
    if r == 0:  # 모두 다 채워졌을 때
        print()
    elif n < r:  # 0Cr인 경우 -> 논리적으로 맞지않음
        return
   	else:
        tr[r-1] <- an[n-1]
        comb(n-1, r-1)
        comb(n-1, r)
```







## 탐욕 알고리즘

